$OpenBSD: patch-src_combined_ffmpeg_ff_video_decoder_c,v 1.18 2014/05/24 16:16:14 brad Exp $

- Simplify FFmpeg video edge handling.
- Add DR1 reenable message.
- Fix multithreading.

--- src/combined/ffmpeg/ff_video_decoder.c.orig	Thu Mar 13 00:06:09 2014
+++ src/combined/ffmpeg/ff_video_decoder.c	Sat May 24 11:17:54 2014
@@ -278,8 +278,19 @@ static int get_buffer (AVCodecContext *context, AVFram
   /* The visible size, may be smaller. */
   int width  = context->width;
   int height = context->height;
+  int top_edge;
   int guarded_render = 0;
 
+  /* multiple threads have individual contexts !! */
+#ifdef AVCODEC_HAS_COLORSPACE
+  if (context != this->context) {
+    if (this->context->colorspace == 2) /* undefined */
+      this->context->colorspace = context->colorspace;
+    if (this->context->color_range == 0)
+      this->context->color_range = context->color_range;
+  }
+#endif
+
   /* A bit of unmotivated paranoia... */
   if (buf_width < width)
     buf_width = width;
@@ -303,7 +314,7 @@ static int get_buffer (AVCodecContext *context, AVFram
   avcodec_align_dimensions(context, &buf_width, &buf_height);
 
 #ifdef ENABLE_VAAPI
-  if( this->context->pix_fmt == PIX_FMT_VAAPI_VLD) {
+  if( context->pix_fmt == PIX_FMT_VAAPI_VLD ) {
 
     av_frame->opaque  = NULL;
     av_frame->data[0] = NULL;
@@ -406,13 +417,18 @@ static int get_buffer (AVCodecContext *context, AVFram
 #endif /* ENABLE_VAAPI */
 
   /* The alignment rhapsody */
-  buf_width  += 2 * this->edge + 15;
-  buf_width  &= ~15;
-  buf_height += 2 * this->edge + 15;
+  /* SSE2+ requirement (U, V rows need to be 16 byte aligned too) */
+  buf_width  += 2 * this->edge + 31;
+  buf_width  &= ~31;
+  /* 2 extra lines for the edge wrap below plus XINE requirement */
+  top_edge = this->edge;
+  if (top_edge)
+    top_edge += 2;
+  buf_height += top_edge + this->edge + 15;
   buf_height &= ~15;
 
-  if ((this->full2mpeg || (this->context->pix_fmt != PIX_FMT_YUV420P &&
-			   this->context->pix_fmt != PIX_FMT_YUVJ420P)) || guarded_render) {
+  if (this->full2mpeg || guarded_render ||
+    (context->pix_fmt != PIX_FMT_YUV420P && context->pix_fmt != PIX_FMT_YUVJ420P)) {
     if (!this->is_direct_rendering_disabled) {
       xprintf(this->stream->xine, XINE_VERBOSITY_LOG,
               _("ffmpeg_video_dec: unsupported frame format, DR1 disabled.\n"));
@@ -449,7 +465,10 @@ static int get_buffer (AVCodecContext *context, AVFram
     }
   }
 
-  this->is_direct_rendering_disabled = 0;
+  if (this->is_direct_rendering_disabled) {
+    xprintf (this->stream->xine, XINE_VERBOSITY_LOG, _("ffmpeg_video_dec: direct rendering enabled\n"));
+    this->is_direct_rendering_disabled = 0;
+  }
 
   img = this->stream->video_out->get_frame (this->stream->video_out,
                                             buf_width,
@@ -503,13 +522,15 @@ static int get_buffer (AVCodecContext *context, AVFram
   av_frame->linesize[2] = img->pitches[2];
 
   if (this->output_format == XINE_IMGFMT_YV12) {
-    av_frame->data[0] += (img->pitches[0] + 1) * this->edge;
-    av_frame->data[1] += (img->pitches[1] + 1) * this->edge / 2;
-    av_frame->data[2] += (img->pitches[2] + 1) * this->edge / 2;
-    img->crop_left   = this->edge;
-    img->crop_top    = this->edge;
-    img->crop_right  = buf_width  - width  - this->edge;
-    img->crop_bottom = buf_height - height - this->edge;
+    /* nasty hack: wrap left edge to the right side to get proper
+       SSE2 alignment on all planes. */
+    av_frame->data[0] += img->pitches[0] * top_edge;
+    av_frame->data[1] += img->pitches[1] * top_edge / 2;
+    av_frame->data[2] += img->pitches[2] * top_edge / 2;
+    img->crop_left   = 0;
+    img->crop_top    = top_edge;
+    img->crop_right  = buf_width  - width;
+    img->crop_bottom = buf_height - height - top_edge;
   }
 
   /* We should really keep track of the ages of xine frames (see
@@ -731,6 +752,7 @@ static void init_video_codec (ff_video_decoder_t *this
   if( this->codec->capabilities & CODEC_CAP_DR1 && this->class->enable_dri ) {
 #ifdef AV_BUFFER
     this->context->get_buffer2 = get_buffer;
+    this->context->thread_safe_callbacks = 1;
 #else
     this->context->get_buffer = get_buffer;
     this->context->release_buffer = release_buffer;
@@ -2280,6 +2302,7 @@ static void ff_free_dr1_frames (ff_video_decoder_t *th
      They will only be replaced when new ones arrive, and freed on codec close.
      They also have no AVCodec.flush () callback for manual freeing (that is,
      avcodec_flush_buffers () does nothing).
+     Even worse: multithreading seems to always do it like that...
      So lets tolerate this behaviour on plain stream seek. */
   if (!all) {
     it = NULL;
@@ -2288,7 +2311,7 @@ static void ff_free_dr1_frames (ff_video_decoder_t *th
       frames++;
     if (!frames)
       return;
-    if (frames < 5) {
+    if (frames < 12) {
       xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
         "ffmpeg_video_dec: tolerating %d held DR1 frames.\n", frames);
       return;
