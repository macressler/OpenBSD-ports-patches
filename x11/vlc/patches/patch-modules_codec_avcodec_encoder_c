$OpenBSD: patch-modules_codec_avcodec_encoder_c,v 1.1 2013/03/09 09:32:03 brad Exp $
--- modules/codec/avcodec/encoder.c.orig	Fri Mar  8 16:31:00 2013
+++ modules/codec/avcodec/encoder.c	Fri Mar  8 16:31:07 2013
@@ -32,6 +32,8 @@
 # include "config.h"
 #endif
 
+#include <assert.h>
+
 #include <vlc_common.h>
 #include <vlc_aout.h>
 #include <vlc_sout.h>
@@ -188,6 +190,42 @@ static const uint16_t mpeg4_default_non_intra_matrix[6
  23, 24, 25, 27, 28, 30, 31, 33,
 };
 
+/**
+ * Deinterleaves audio samples within a block of samples.
+ * \param dst destination buffer for planar samples
+ * \param src source buffer with interleaved samples
+ * \param samples number of samples (per channel/per plane)
+ * \param chans channels/planes count
+ * \param fourcc sample format (must be a linear sample format)
+ * \note The samples must be naturally aligned in memory.
+ * \warning Destination and source buffers MUST NOT overlap.
+ */
+static void Deinterleave( void *restrict dst, const void *restrict src,
+                      unsigned samples, unsigned chans, vlc_fourcc_t fourcc )
+{
+#define DEINTERLEAVE_TYPE(type) \
+do { \
+    type *d = dst; \
+    const type *s = src; \
+    for( size_t i = 0; i < chans; i++ ) { \
+        for( size_t j = 0, k = 0; j < samples; j++, k += chans ) \
+            *(d++) = s[k]; \
+        s++; \
+    } \
+} while(0)
+
+    switch( fourcc )
+    {
+        case VLC_CODEC_U8:   DEINTERLEAVE_TYPE(uint8_t);  break;
+        case VLC_CODEC_S16N: DEINTERLEAVE_TYPE(uint16_t); break;
+        case VLC_CODEC_FL32: DEINTERLEAVE_TYPE(float);    break;
+        case VLC_CODEC_S32N: DEINTERLEAVE_TYPE(int32_t);  break;
+        case VLC_CODEC_FL64: DEINTERLEAVE_TYPE(double);   break;
+        default:             assert(0);
+    }
+#undef DEINTERLEAVE_TYPE
+}
+
 /*****************************************************************************
  * OpenEncoder: probe the encoder
  *****************************************************************************/
@@ -612,7 +650,8 @@ int OpenEncoder( vlc_object_t *p_this )
         p_context->sample_fmt  = p_codec->sample_fmts ?
                                     p_codec->sample_fmts[0] :
                                     AV_SAMPLE_FMT_S16;
-        p_enc->fmt_in.i_codec  = VLC_CODEC_S16N;
+        p_enc->fmt_in.i_codec  = GetVlcAudioFormat( p_context->sample_fmt );
+
         p_context->sample_rate = p_enc->fmt_out.audio.i_rate;
         p_context->time_base.num = 1;
         p_context->time_base.den = p_context->sample_rate;
@@ -826,9 +865,9 @@ int OpenEncoder( vlc_object_t *p_this )
 
     if( p_enc->fmt_in.i_cat == AUDIO_ES )
     {
-        GetVlcAudioFormat( &p_enc->fmt_in.i_codec,
-                           &p_enc->fmt_in.audio.i_bitspersample,
-                           p_sys->p_context->sample_fmt );
+        p_enc->fmt_in.i_codec = GetVlcAudioFormat( p_sys->p_context->sample_fmt );
+        p_enc->fmt_in.audio.i_bitspersample = aout_BitsPerSample( p_enc->fmt_in.i_codec );
+
         p_sys->i_sample_bytes = (p_enc->fmt_in.audio.i_bitspersample / 8) *
                                 p_context->channels;
         p_sys->i_frame_size = p_context->frame_size > 1 ?
@@ -1105,8 +1144,12 @@ static block_t *EncodeAudio( encoder_t *p_enc, aout_bu
             int i_size = (p_sys->i_frame_size - i_delay_size) *
                          p_sys->i_sample_bytes;
 
-            memcpy( p_sys->p_buffer + i_delay_size * p_sys->i_sample_bytes,
-                    p_buffer, i_size );
+            if( av_sample_fmt_is_planar( p_sys->p_context->sample_fmt ) )
+                Deinterleave( &p_sys->p_buffer[i_delay_size * p_sys->i_sample_bytes],
+                        p_buffer, i_samples_delay, p_enc->fmt_in.audio.i_channels, p_enc->fmt_in.i_codec );
+            else
+                memcpy( p_sys->p_buffer + i_delay_size * p_sys->i_sample_bytes,
+                        p_buffer, i_size );
             p_buffer -= i_delay_size * p_sys->i_sample_bytes;
             i_samples += i_samples_delay;
             i_samples_delay = 0;
@@ -1115,7 +1158,14 @@ static block_t *EncodeAudio( encoder_t *p_enc, aout_bu
         }
         else
         {
-            p_samples = p_buffer;
+            if( av_sample_fmt_is_planar( p_sys->p_context->sample_fmt ) ) {
+                Deinterleave( p_sys->p_buffer,
+                        p_buffer, p_sys->i_frame_size,
+                        p_enc->fmt_in.audio.i_channels,
+                        p_enc->fmt_in.i_codec );
+                p_samples = p_sys->p_buffer;
+            } else
+                p_samples = p_buffer;
         }
 
         i_out = avcodec_encode_audio( p_sys->p_context, p_sys->p_buffer_out,
@@ -1148,9 +1198,13 @@ static block_t *EncodeAudio( encoder_t *p_enc, aout_bu
     /* Backup the remaining raw samples */
     if( i_samples )
     {
-        memcpy( &p_sys->p_buffer[i_samples_delay * p_sys->i_sample_bytes],
-                p_buffer,
-                i_samples * p_sys->i_sample_bytes );
+        if( av_sample_fmt_is_planar( p_sys->p_context->sample_fmt ) )
+            Deinterleave( &p_sys->p_buffer[i_samples_delay * p_sys->i_sample_bytes],
+                    p_buffer, i_samples, p_enc->fmt_in.audio.i_channels, p_enc->fmt_in.i_codec );
+        else
+            memcpy( &p_sys->p_buffer[i_samples_delay * p_sys->i_sample_bytes],
+                    p_buffer,
+                    i_samples * p_sys->i_sample_bytes );
     }
 
     return p_chain;
