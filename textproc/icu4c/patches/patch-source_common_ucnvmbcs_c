$OpenBSD: patch-source_common_ucnvmbcs_c,v 1.1 2012/12/08 13:18:46 ajacoutot Exp $

On OpenBSD, si_value is already defined in <sys/siginfo.h>.

--- source/common/ucnvmbcs.c.orig	Thu Dec  6 16:08:47 2012
+++ source/common/ucnvmbcs.c	Thu Dec  6 16:09:24 2012
@@ -3940,9 +3940,9 @@ ucnv_MBCSFromUnicodeWithOffsets(UConverterFromUnicodeA
     uint32_t stage2Entry;
     uint32_t asciiRoundtrips;
     uint32_t value;
-    uint8_t si_value[2] = {0, 0}; 
+    uint8_t icu_si_value[2] = {0, 0}; 
     uint8_t so_value[2] = {0, 0}; 
-    uint8_t si_value_length, so_value_length;
+    uint8_t icu_si_value_length, so_value_length;
     int32_t length = 0, prevLength;
     uint8_t unicodeMask;
 
@@ -4015,7 +4015,7 @@ ucnv_MBCSFromUnicodeWithOffsets(UConverterFromUnicodeA
     nextSourceIndex=0;
 
     /* Get the SI/SO character for the converter */
-    si_value_length = getSISOBytes(SI, cnv->options, si_value);
+    icu_si_value_length = getSISOBytes(SI, cnv->options, icu_si_value);
     so_value_length = getSISOBytes(SO, cnv->options, so_value);
 
     /* conversion loop */
@@ -4107,12 +4107,12 @@ ucnv_MBCSFromUnicodeWithOffsets(UConverterFromUnicodeA
                             length=1;
                         } else {
                             /* change from double-byte mode to single-byte */
-                            if (si_value_length == 1) {
-                                value|=(uint32_t)si_value[0]<<8;
+                            if (icu_si_value_length == 1) {
+                                value|=(uint32_t)icu_si_value[0]<<8;
                                 length = 2;
-                            } else if (si_value_length == 2) {
-                                value|=(uint32_t)si_value[1]<<8;
-                                value|=(uint32_t)si_value[0]<<16;
+                            } else if (icu_si_value_length == 2) {
+                                value|=(uint32_t)icu_si_value[1]<<8;
+                                value|=(uint32_t)icu_si_value[0]<<16;
                                 length = 3;
                             }
                             prevLength=1;
@@ -4339,12 +4339,12 @@ getTrail:
                             length=1;
                         } else {
                             /* change from double-byte mode to single-byte */
-                            if (si_value_length == 1) {
-                                value|=(uint32_t)si_value[0]<<8;
+                            if (icu_si_value_length == 1) {
+                                value|=(uint32_t)icu_si_value[0]<<8;
                                 length = 2;
-                            } else if (si_value_length == 2) {
-                                value|=(uint32_t)si_value[1]<<8;
-                                value|=(uint32_t)si_value[0]<<16;
+                            } else if (icu_si_value_length == 2) {
+                                value|=(uint32_t)icu_si_value[1]<<8;
+                                value|=(uint32_t)icu_si_value[0]<<16;
                                 length = 3;
                             }
                             prevLength=1;
@@ -4614,14 +4614,14 @@ unassigned:
     ) {
         /* EBCDIC_STATEFUL ending with DBCS: emit an SI to return the output stream to SBCS */
         if(targetCapacity>0) {
-            *target++=(uint8_t)si_value[0];
-            if (si_value_length == 2) {
+            *target++=(uint8_t)icu_si_value[0];
+            if (icu_si_value_length == 2) {
                 if (targetCapacity<2) {
-                    cnv->charErrorBuffer[0]=(uint8_t)si_value[1];
+                    cnv->charErrorBuffer[0]=(uint8_t)icu_si_value[1];
                     cnv->charErrorBufferLength=1;
                     *pErrorCode=U_BUFFER_OVERFLOW_ERROR;
                 } else {
-                    *target++=(uint8_t)si_value[1];
+                    *target++=(uint8_t)icu_si_value[1];
                 }
             }
             if(offsets!=NULL) {
@@ -4630,11 +4630,11 @@ unassigned:
             }
         } else {
             /* target is full */
-            cnv->charErrorBuffer[0]=(uint8_t)si_value[0];
-            if (si_value_length == 2) {
-                cnv->charErrorBuffer[1]=(uint8_t)si_value[1];
+            cnv->charErrorBuffer[0]=(uint8_t)icu_si_value[0];
+            if (icu_si_value_length == 2) {
+                cnv->charErrorBuffer[1]=(uint8_t)icu_si_value[1];
             }
-            cnv->charErrorBufferLength=si_value_length;
+            cnv->charErrorBufferLength=icu_si_value_length;
             *pErrorCode=U_BUFFER_OVERFLOW_ERROR;
         }
         prevLength=1; /* we switched into SBCS */
