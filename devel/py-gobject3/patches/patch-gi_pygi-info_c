$OpenBSD: patch-gi_pygi-info_c,v 1.1 2012/07/20 07:14:12 ajacoutot Exp $

From 16280d6985f2cf4db9cf062e857650e620fd9da8 Mon Sep 17 00:00:00 2001
From: Martin Pitt <martinpitt@gnome.org>
Date: Mon, 25 Jun 2012 07:40:38 +0000
Subject: Escape identifiers which are Python keywords

--- gi/pygi-info.c.orig	Mon May 14 18:49:12 2012
+++ gi/pygi-info.c	Wed Jul 18 17:41:11 2012
@@ -95,7 +95,43 @@ PYGLIB_DEFINE_TYPE("gi.BaseInfo", PyGIBaseInfo_Type, P
 static PyObject *
 _wrap_g_base_info_get_name (PyGIBaseInfo *self)
 {
-    return PYGLIB_PyUnicode_FromString (g_base_info_get_name (self->info));
+    /* It may be better to use keyword.iskeyword(); keep in sync with
+     * python -c 'import keyword; print(keyword.kwlist)' */
+#if PY_VERSION_HEX < 0x03000000
+    /* Python 2.x */
+    static const gchar* keywords[] = {"and", "as", "assert", "break", "class",
+        "continue", "def", "del", "elif", "else", "except", "exec", "finally",
+        "for", "from", "global", "if", "import", "in", "is", "lambda", "not",
+        "or", "pass", "print", "raise", "return", "try", "while", "with",
+        "yield", NULL};
+#elif PY_VERSION_HEX < 0x04000000
+    /* Python 3.x; note that we explicitly keep "print"; it is not a keyword
+     * any more, but we do not want to break API between Python versions */
+    static const gchar* keywords[] = {"False", "None", "True", "and", "as",
+        "assert", "break", "class", "continue", "def", "del", "elif", "else",
+        "except", "finally", "for", "from", "global", "if", "import", "in",
+        "is", "lambda", "nonlocal", "not", "or", "pass", "raise", "return",
+        "try", "while", "with", "yield",
+        "print", NULL};
+#else
+    #error Need keyword list for this major Python version
+#endif
+
+    const gchar *name, **i;
+
+    name = g_base_info_get_name (self->info);
+
+    /* escape keywords */
+    for (i = keywords; *i != NULL; ++i) {
+        if (strcmp (name, *i) == 0) {
+            gchar *escaped = g_strconcat (name, "_", NULL);
+            PyObject *obj = PYGLIB_PyUnicode_FromString (escaped);
+            g_free (escaped);
+            return obj;
+        }
+    }
+
+    return PYGLIB_PyUnicode_FromString (name);
 }
 
 static PyObject *
